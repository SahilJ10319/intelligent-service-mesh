# Application Identity
spring.application.name=neuragate-mesh
server.port=8080

# Virtual Threads - using Project Loom for high concurrency
spring.threads.virtual.enabled=true

# Redis Configuration
spring.data.redis.host=localhost
spring.data.redis.port=6379

# Redis key-space for routes
metadata.route-key=gateway_routes

# Resilience4j Circuit Breaker defaults
resilience4j.circuitbreaker.configs.default.failure-rate-threshold=50
resilience4j.circuitbreaker.configs.default.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.configs.default.sliding-window-size=10
resilience4j.circuitbreaker.configs.default.minimum-number-of-calls=5
resilience4j.circuitbreaker.configs.default.permitted-number-of-calls-in-half-open-state=3
resilience4j.circuitbreaker.configs.default.register-health-indicator=true
resilience4j.circuitbreaker.configs.default.sliding-window-type=COUNT_BASED

# Resilience4j Retry defaults
# Day 10: Enhanced with exponential backoff and jitter
resilience4j.retry.configs.default.max-attempts=3
resilience4j.retry.configs.default.wait-duration=500ms
resilience4j.retry.configs.default.enable-exponential-backoff=true
resilience4j.retry.configs.default.exponential-backoff-multiplier=2
resilience4j.retry.configs.default.enable-random-jitter=true
resilience4j.retry.configs.default.retry-exceptions=java.net.ConnectException,java.net.SocketTimeoutException,java.io.IOException,org.springframework.web.reactive.function.client.WebClientRequestException

# Day 10: Retry instance for dynamic routes
resilience4j.retry.instances.dynamicRouteRetry.max-attempts=3
resilience4j.retry.instances.dynamicRouteRetry.wait-duration=500ms
resilience4j.retry.instances.dynamicRouteRetry.enable-exponential-backoff=true
resilience4j.retry.instances.dynamicRouteRetry.exponential-backoff-multiplier=2
resilience4j.retry.instances.dynamicRouteRetry.enable-random-jitter=true
resilience4j.retry.instances.dynamicRouteRetry.retry-exceptions=java.net.ConnectException,java.net.SocketTimeoutException,java.io.IOException

# Retry instance for backend services (more aggressive)
resilience4j.retry.instances.backendRetry.max-attempts=4
resilience4j.retry.instances.backendRetry.wait-duration=300ms
resilience4j.retry.instances.backendRetry.enable-exponential-backoff=true
resilience4j.retry.instances.backendRetry.exponential-backoff-multiplier=2
resilience4j.retry.instances.backendRetry.enable-random-jitter=true

# Retry instance for critical services (conservative)
resilience4j.retry.instances.criticalRetry.max-attempts=2
resilience4j.retry.instances.criticalRetry.wait-duration=1000ms
resilience4j.retry.instances.criticalRetry.enable-exponential-backoff=true
resilience4j.retry.instances.criticalRetry.exponential-backoff-multiplier=1.5
resilience4j.retry.instances.criticalRetry.enable-random-jitter=true

# Day 13: Distributed Rate Limiting Configuration
# Redis-based rate limiting using token bucket algorithm

# Default rate limiter settings
spring.cloud.gateway.redis-rate-limiter.replenish-rate=10
spring.cloud.gateway.redis-rate-limiter.burst-capacity=20
spring.cloud.gateway.redis-rate-limiter.requested-tokens=1

# Redis rate limiter configuration
spring.cloud.gateway.redis-rate-limiter.include-headers=true
spring.cloud.gateway.redis-rate-limiter.config.fallback-enabled=true

# Redis keyspace for rate limiting
spring.data.redis.rate-limiter-key-prefix=request_rate_limiter

# Logging
logging.level.root=INFO
logging.level.com.neuragate=DEBUG
logging.level.com.neuragate.gateway.controller.AdminController=DEBUG
logging.level.com.neuragate.repository=DEBUG
logging.level.com.neuragate.config.CircuitBreakerEventConfig=INFO
logging.level.com.neuragate.config.RetryEventLogger=INFO
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} %highlight(%-5level) [%thread] %cyan(%logger{36}) - %msg%n

# Actuator endpoints
management.endpoints.web.exposure.include=health,info,metrics,circuitbreakers,ratelimiters
management.endpoint.health.show-details=always
management.endpoint.health.show-components=always
management.health.circuitbreakers.enabled=true

# Redis health check configuration
# Check Redis connectivity every 10 seconds
management.health.redis.enabled=true
spring.data.redis.timeout=2000ms

# Custom health indicator for gateway self-awareness
# The gateway uses this to determine if it should use Redis or fallback routes
logging.level.com.neuragate.health=DEBUG

# Day 8: Circuit Breaker Named Instances
# Named circuit breaker for backend services
resilience4j.circuitbreaker.instances.backendService.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.backendService.wait-duration-in-open-state=10s
resilience4j.circuitbreaker.instances.backendService.sliding-window-size=10
resilience4j.circuitbreaker.instances.backendService.sliding-window-type=COUNT_BASED
resilience4j.circuitbreaker.instances.backendService.minimum-number-of-calls=5
resilience4j.circuitbreaker.instances.backendService.permitted-number-of-calls-in-half-open-state=3
resilience4j.circuitbreaker.instances.backendService.automatic-transition-from-open-to-half-open-enabled=true
resilience4j.circuitbreaker.instances.backendService.register-health-indicator=true

# Circuit breaker for critical services (more lenient)
resilience4j.circuitbreaker.instances.criticalService.failure-rate-threshold=70
resilience4j.circuitbreaker.instances.criticalService.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.instances.criticalService.sliding-window-size=20
resilience4j.circuitbreaker.instances.criticalService.minimum-number-of-calls=10
resilience4j.circuitbreaker.instances.criticalService.permitted-number-of-calls-in-half-open-state=5
resilience4j.circuitbreaker.instances.criticalService.register-health-indicator=true

# Day 9: Circuit Breaker for Dynamic Routes
# All dynamic routes from Redis get this circuit breaker automatically
resilience4j.circuitbreaker.instances.dynamicRoute.failure-rate-threshold=60
resilience4j.circuitbreaker.instances.dynamicRoute.wait-duration-in-open-state=15s
resilience4j.circuitbreaker.instances.dynamicRoute.sliding-window-size=15
resilience4j.circuitbreaker.instances.dynamicRoute.sliding-window-type=COUNT_BASED
resilience4j.circuitbreaker.instances.dynamicRoute.minimum-number-of-calls=5
resilience4j.circuitbreaker.instances.dynamicRoute.permitted-number-of-calls-in-half-open-state=3
resilience4j.circuitbreaker.instances.dynamicRoute.automatic-transition-from-open-to-half-open-enabled=true
resilience4j.circuitbreaker.instances.dynamicRoute.register-health-indicator=true

# Enable circuit breaker metrics
management.metrics.distribution.percentiles-histogram.resilience4j.circuitbreaker.calls=true

# Day 9: Circuit breaker event logging
logging.level.com.neuragate.config.CircuitBreakerEventConfig=INFO

# Day 10: Retry event logging
logging.level.com.neuragate.config.RetryEventLogger=INFO

# Day 14: Test Profile Configuration
# Enhanced logging for integration tests
logging.level.org.springframework.cloud.gateway=DEBUG
logging.level.org.springframework.web.reactive=DEBUG
logging.level.reactor.netty=DEBUG
