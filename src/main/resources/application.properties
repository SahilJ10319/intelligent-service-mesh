# Application Identity
spring.application.name=neuragate-mesh
server.port=8080

# Day 25: Dashboard static resources and endpoint
spring.web.resources.static-locations=classpath:/static/
spring.mvc.static-path-pattern=/**
# Dashboard available at http://localhost:8080/index.html
# SSE stream at http://localhost:8080/dashboard/stream

# Day 26: JWT Security
# Secret must be at least 32 characters for HMAC-SHA256
neuragate.security.jwt.secret=NeuraGate-Super-Secret-Key-Day26-Production-Ready-256bit
neuragate.security.jwt.expiration-ms=3600000
# Dev credentials for POST /auth/token (replace with proper auth in production)
neuragate.security.jwt.dev-username=neuragate
neuragate.security.jwt.dev-password=secret

# Virtual Threads - using Project Loom for high concurrency
spring.threads.virtual.enabled=true

# Redis Configuration
spring.data.redis.host=localhost
spring.data.redis.port=6379

# Redis key-space for routes
metadata.route-key=gateway_routes

# Day 15: Kafka Configuration
# Day 17: Enhanced for telemetry performance
# Event streaming for telemetry and observability
spring.kafka.bootstrap-servers=localhost:9092

# Kafka Producer Configuration
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
spring.kafka.producer.acks=1
spring.kafka.producer.retries=3
spring.kafka.producer.properties.enable.idempotence=true
spring.kafka.producer.properties.compression.type=gzip

# Day 17: Performance tuning for high-throughput telemetry
spring.kafka.producer.buffer-memory=33554432
spring.kafka.producer.batch-size=16384
spring.kafka.producer.linger-ms=10
spring.kafka.producer.properties.max.in.flight.requests.per.connection=5

# Telemetry topic configuration
telemetry.topic.name=gateway-telemetry
telemetry.topic.errors=gateway-errors
telemetry.topic.routes=gateway-routes

# Day 19: Kafka Consumer Configuration
# Analytics consumer for telemetry processing
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.group-id=neuragate-analytics
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.consumer.enable-auto-commit=true
spring.kafka.consumer.auto-commit-interval-ms=5000
spring.kafka.consumer.max-poll-records=500
spring.kafka.consumer.properties.spring.json.trusted.packages=*
spring.kafka.consumer.properties.spring.json.value.default.type=com.neuragate.telemetry.GatewayTelemetry

# Day 20: Prometheus Actuator Endpoints
management.endpoints.web.exposure.include=health,info,prometheus,metrics
management.endpoint.health.show-details=always
management.endpoint.prometheus.enabled=true
management.metrics.export.prometheus.enabled=true

# Day 21: Anomaly Detection Thresholds
neuragate.anomaly.latency-threshold-ms=500
neuragate.anomaly.consecutive-failures-threshold=3
neuragate.anomaly.latency-spike-multiplier=2.0

# Day 22-23: AI Advisor Configuration
# LLM provider: gemini, openai, or local
neuragate.ai.provider=gemini
neuragate.ai.model-id=gemini-1.5-flash
neuragate.ai.api-key=${GEMINI_API_KEY:your-api-key-here}
neuragate.ai.temperature=0.3
neuragate.ai.max-tokens=1000
neuragate.ai.enabled=true

# Day 24: Autonomous Execution Safety Limits
# Human-in-loop: Require human approval for critical changes
neuragate.ai.human-in-loop=true
# Auto-execute threshold: Minimum confidence to auto-execute (0-100)
neuragate.ai.auto-execute-threshold=80
# Max rate limit change: Maximum percentage change in one go (prevents drastic changes)
neuragate.ai.max-rate-limit-change=50
# Max timeout change: Maximum timeout increase in seconds
neuragate.ai.max-timeout-change-seconds=30
# Enable autonomous execution
neuragate.ai.autonomous-mode=false

# Resilience4j Circuit Breaker defaults
resilience4j.circuitbreaker.configs.default.failure-rate-threshold=50
resilience4j.circuitbreaker.configs.default.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.configs.default.sliding-window-size=10
resilience4j.circuitbreaker.configs.default.minimum-number-of-calls=5
resilience4j.circuitbreaker.configs.default.permitted-number-of-calls-in-half-open-state=3
resilience4j.circuitbreaker.configs.default.register-health-indicator=true
resilience4j.circuitbreaker.configs.default.sliding-window-type=COUNT_BASED

# Resilience4j Retry defaults
# Day 10: Enhanced with exponential backoff and jitter
resilience4j.retry.configs.default.max-attempts=3
resilience4j.retry.configs.default.wait-duration=500ms
resilience4j.retry.configs.default.enable-exponential-backoff=true
resilience4j.retry.configs.default.exponential-backoff-multiplier=2
resilience4j.retry.configs.default.enable-random-jitter=true
resilience4j.retry.configs.default.retry-exceptions=java.net.ConnectException,java.net.SocketTimeoutException,java.io.IOException,org.springframework.web.reactive.function.client.WebClientRequestException

# Day 10: Retry instance for dynamic routes
resilience4j.retry.instances.dynamicRouteRetry.max-attempts=3
resilience4j.retry.instances.dynamicRouteRetry.wait-duration=500ms
resilience4j.retry.instances.dynamicRouteRetry.enable-exponential-backoff=true
resilience4j.retry.instances.dynamicRouteRetry.exponential-backoff-multiplier=2
resilience4j.retry.instances.dynamicRouteRetry.enable-random-jitter=true
resilience4j.retry.instances.dynamicRouteRetry.retry-exceptions=java.net.ConnectException,java.net.SocketTimeoutException,java.io.IOException

# Retry instance for backend services (more aggressive)
resilience4j.retry.instances.backendRetry.max-attempts=4
resilience4j.retry.instances.backendRetry.wait-duration=300ms
resilience4j.retry.instances.backendRetry.enable-exponential-backoff=true
resilience4j.retry.instances.backendRetry.exponential-backoff-multiplier=2
resilience4j.retry.instances.backendRetry.enable-random-jitter=true

# Retry instance for critical services (conservative)
resilience4j.retry.instances.criticalRetry.max-attempts=2
resilience4j.retry.instances.criticalRetry.wait-duration=1000ms
resilience4j.retry.instances.criticalRetry.enable-exponential-backoff=true
resilience4j.retry.instances.criticalRetry.exponential-backoff-multiplier=1.5
resilience4j.retry.instances.criticalRetry.enable-random-jitter=true

# Day 13: Distributed Rate Limiting Configuration
# Redis-based rate limiting using token bucket algorithm

# Default rate limiter settings
spring.cloud.gateway.redis-rate-limiter.replenish-rate=10
spring.cloud.gateway.redis-rate-limiter.burst-capacity=20
spring.cloud.gateway.redis-rate-limiter.requested-tokens=1

# Redis rate limiter configuration
spring.cloud.gateway.redis-rate-limiter.include-headers=true
spring.cloud.gateway.redis-rate-limiter.config.fallback-enabled=true

# Redis keyspace for rate limiting
spring.data.redis.rate-limiter-key-prefix=request_rate_limiter

# Logging
logging.level.root=INFO
logging.level.com.neuragate=DEBUG
logging.level.com.neuragate.gateway.controller.AdminController=DEBUG
logging.level.com.neuragate.repository=DEBUG
logging.level.com.neuragate.config.CircuitBreakerEventConfig=INFO
logging.level.com.neuragate.config.RetryEventLogger=INFO
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} %highlight(%-5level) [%thread] %cyan(%logger{36}) - %msg%n

# Actuator endpoints
management.endpoints.web.exposure.include=health,info,metrics,circuitbreakers,ratelimiters
management.endpoint.health.show-details=always
management.endpoint.health.show-components=always
management.health.circuitbreakers.enabled=true

# Redis health check configuration
# Check Redis connectivity every 10 seconds
management.health.redis.enabled=true
spring.data.redis.timeout=2000ms

# Custom health indicator for gateway self-awareness
# The gateway uses this to determine if it should use Redis or fallback routes
logging.level.com.neuragate.health=DEBUG

# Day 8: Circuit Breaker Named Instances
# Named circuit breaker for backend services
resilience4j.circuitbreaker.instances.backendService.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.backendService.wait-duration-in-open-state=10s
resilience4j.circuitbreaker.instances.backendService.sliding-window-size=10
resilience4j.circuitbreaker.instances.backendService.sliding-window-type=COUNT_BASED
resilience4j.circuitbreaker.instances.backendService.minimum-number-of-calls=5
resilience4j.circuitbreaker.instances.backendService.permitted-number-of-calls-in-half-open-state=3
resilience4j.circuitbreaker.instances.backendService.automatic-transition-from-open-to-half-open-enabled=true
resilience4j.circuitbreaker.instances.backendService.register-health-indicator=true

# Circuit breaker for critical services (more lenient)
resilience4j.circuitbreaker.instances.criticalService.failure-rate-threshold=70
resilience4j.circuitbreaker.instances.criticalService.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.instances.criticalService.sliding-window-size=20
resilience4j.circuitbreaker.instances.criticalService.minimum-number-of-calls=10
resilience4j.circuitbreaker.instances.criticalService.permitted-number-of-calls-in-half-open-state=5
resilience4j.circuitbreaker.instances.criticalService.register-health-indicator=true

# Day 9: Circuit Breaker for Dynamic Routes
# All dynamic routes from Redis get this circuit breaker automatically
resilience4j.circuitbreaker.instances.dynamicRoute.failure-rate-threshold=60
resilience4j.circuitbreaker.instances.dynamicRoute.wait-duration-in-open-state=15s
resilience4j.circuitbreaker.instances.dynamicRoute.sliding-window-size=15
resilience4j.circuitbreaker.instances.dynamicRoute.sliding-window-type=COUNT_BASED
resilience4j.circuitbreaker.instances.dynamicRoute.minimum-number-of-calls=5
resilience4j.circuitbreaker.instances.dynamicRoute.permitted-number-of-calls-in-half-open-state=3
resilience4j.circuitbreaker.instances.dynamicRoute.automatic-transition-from-open-to-half-open-enabled=true
resilience4j.circuitbreaker.instances.dynamicRoute.register-health-indicator=true

# Enable circuit breaker metrics
management.metrics.distribution.percentiles-histogram.resilience4j.circuitbreaker.calls=true

# Day 9: Circuit breaker event logging
logging.level.com.neuragate.config.CircuitBreakerEventConfig=INFO

# Day 10: Retry event logging
logging.level.com.neuragate.config.RetryEventLogger=INFO

# Day 14: Test Profile Configuration
# Enhanced logging for integration tests
logging.level.org.springframework.cloud.gateway=DEBUG
logging.level.org.springframework.web.reactive=DEBUG
logging.level.reactor.netty=DEBUG
